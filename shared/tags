!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ARPCacheEntry	network.c	/^typedef struct ARPCacheEntry {$/;"	s	file:
ARPCacheEntry	network.c	/^} ARPCacheEntry;$/;"	t	typeref:struct:ARPCacheEntry	file:
ARPPacket	network.c	/^typedef struct ARPPacket {$/;"	s	file:
ARPPacket	network.c	/^} ARPPacket;$/;"	t	typeref:struct:ARPPacket	file:
BmpHeader	display.c	/^} BmpHeader;$/;"	t	typeref:struct:__anon2	file:
BmpHeaderSize	display.c	189;"	d	file:
BmpMagic	display.c	/^} BmpMagic;$/;"	t	typeref:struct:__anon1	file:
CACHELINE	intercore.h	156;"	d
CACHELINE	mcLibc.c	/^int **responseAreas CACHELINE;$/;"	v
Condition	threads.c	/^struct Condition {$/;"	s	file:
Condition	threads.h	/^typedef struct Condition * Condition;$/;"	t	typeref:struct:Condition
Cycles	threads.c	/^typedef long long int Cycles;$/;"	t	file:
DEVICE_COUNTERS	counters.h	14;"	d
DEVICE_MONITORS	cache_monitor.h	14;"	d
DEVICE_MONITORS	monitor.h	14;"	d
DEVICE_TIMERINTRERUPT	timerInterrupt.h	14;"	d
DHCPHeader	network.c	/^typedef struct DHCPHeader {$/;"	s	file:
DHCPHeader	network.c	/^} DHCPHeader;$/;"	t	typeref:struct:DHCPHeader	file:
DISPLAYHEIGHT	display.h	20;"	d
DISPLAYWIDTH	display.h	19;"	d
DNSAddrs	network.c	/^typedef IPAddr DNSAddrs[maxServers];$/;"	t	file:
DNSHeader	network.c	/^typedef struct DNSHeader {$/;"	s	file:
DNSHeader	network.c	/^} DNSHeader;$/;"	t	typeref:struct:DNSHeader	file:
Enet	network.h	/^typedef struct Enet {         \/\/ Ethernet packet payload, without header$/;"	s
Enet	network.h	/^} Enet;$/;"	t	typeref:struct:Enet
EnetPending	enet.c	/^typedef struct EnetPending { \/\/ incoming packet delayed pending transmit ack$/;"	s	file:
EnetPending	enet.c	/^} *EnetPending;$/;"	t	typeref:struct:EnetPending	file:
EnetReceiver	network.h	/^typedef void (* EnetReceiver)(MAC srce, Uint16 type, Enet *buf, Uint32 len,$/;"	t
FRAMESIZE	display.h	21;"	d
GIFTOTALSYMBOLS	display.c	288;"	d	file:
GifGCE	display.h	/^} GifGCE;$/;"	t	typeref:struct:__anon6
GifHeader	display.c	/^} GifHeader;$/;"	t	typeref:struct:__anon3	file:
GifImage	display.h	/^} GifImage;$/;"	t	typeref:struct:__anon7
GifImageDesc	display.c	/^} GifImageDesc;$/;"	t	typeref:struct:__anon4	file:
HEADERS	Makefile	/^HEADERS = \\$/;"	m
ICMP	network.h	/^typedef struct ICMP {          \/\/ ICMP packet for transmission (only)$/;"	s
ICMP	network.h	/^} ICMP;$/;"	t	typeref:struct:ICMP
ICMPHeader	network.h	/^typedef struct ICMPHeader {$/;"	s
ICMPHeader	network.h	/^} ICMPHeader;$/;"	t	typeref:struct:ICMPHeader
ICMPReceiver	network.h	/^typedef void (* ICMPReceiver)(IP *buf, Uint32 len);$/;"	t
IP	network.h	/^typedef struct IP {           \/\/ complete IP packet$/;"	s
IP	network.h	/^} IP;$/;"	t	typeref:struct:IP
IPAddr	network.h	/^typedef Uint32 IPAddr;        \/\/ IP address, in hardware order$/;"	t
IPHeader	network.h	/^typedef struct IPHeader {     \/\/ static part of IP header$/;"	s
IPHeader	network.h	/^} IPHeader;$/;"	t	typeref:struct:IPHeader
IPReceiver	network.h	/^typedef void (* IPReceiver)(IP *buf, Uint32 len, int broadcast);$/;"	t
Image	display.h	/^} Image;$/;"	t	typeref:struct:__anon5
IntercoreMessage	intercore.h	/^typedef unsigned int IntercoreMessage[63];$/;"	t
Listener	tcp.c	/^typedef struct Listener {$/;"	s	file:
Listener	tcp.c	/^} * Listener;$/;"	t	typeref:struct:Listener	file:
MAC	network.h	/^typedef struct MAC {          \/\/ Ethernet MAC address, in network byte order$/;"	s
MAC	network.h	/^} MAC;$/;"	t	typeref:struct:MAC
MQMessage	network.h	/^typedef unsigned int MQMessage[63];$/;"	t
MQReceiver	network.h	/^typedef void (* MQReceiver)(unsigned int srce, unsigned int type,$/;"	t
MSSOption	tcp.c	/^typedef struct MSSOption {$/;"	s	file:
MSSOption	tcp.c	/^} MSSOption;$/;"	t	typeref:struct:MSSOption	file:
Microsecs	threads.h	/^typedef long long int Microsecs;$/;"	t
Mutex	threads.c	/^struct Mutex {$/;"	s	file:
Mutex	threads.h	/^typedef struct Mutex * Mutex;$/;"	t	typeref:struct:Mutex
OBJS	Makefile	/^OBJS = \\$/;"	m
Octet	network.h	/^typedef unsigned char Octet;$/;"	t
OneGifImage	display.h	/^typedef struct OneGifImage { \/\/ One image within a GIF file$/;"	s
OneGifImage	display.h	/^} OneGifImage;$/;"	t	typeref:struct:OneGifImage
Pixel	display.h	/^typedef unsigned int Pixel;$/;"	t
Queue	threads.h	/^typedef struct Queue {$/;"	s
Queue	threads.h	/^} * Queue;$/;"	t	typeref:struct:Queue
SaveArea	intercore.h	/^typedef struct SaveArea {$/;"	s
SaveArea	intercore.h	/^} SaveArea;$/;"	t	typeref:struct:SaveArea
Semaphore	threads.c	/^struct Semaphore {$/;"	s	file:
Semaphore	threads.h	/^typedef struct Semaphore * Semaphore;$/;"	t	typeref:struct:Semaphore
TCP	network.h	/^typedef struct TCP * TCP;    \/\/ TCP connection handle$/;"	t	typeref:struct:TCP
TCP	tcp.c	/^struct TCP {              \/\/ Connection state block$/;"	s	file:
TCPHeader	tcp.c	/^typedef struct TCPHeader {$/;"	s	file:
TCPHeader	tcp.c	/^} TCPHeader;$/;"	t	typeref:struct:TCPHeader	file:
TCPPort	network.h	/^typedef Uint16 TCPPort;      \/\/ TCP port number, in hardware order$/;"	t
TFTPHeader	tftp.c	/^typedef struct TFTPHeader {$/;"	s	file:
TFTPHeader	tftp.c	/^} TFTPHeader;$/;"	t	typeref:struct:TFTPHeader	file:
Thread	threads.c	/^struct Thread {$/;"	s	file:
Thread	threads.h	/^typedef struct Thread * Thread;$/;"	t	typeref:struct:Thread
TransmitElem	tcp.c	/^typedef struct TransmitElem { \/\/ (re)transmission queue element$/;"	s	file:
TransmitElem	tcp.c	/^} TransmitElem;$/;"	t	typeref:struct:TransmitElem	file:
UDP	network.h	/^typedef struct UDP {          \/\/ UDP packet for transmission (only)$/;"	s
UDP	network.h	/^} UDP;$/;"	t	typeref:struct:UDP
UDPElem	network.c	/^typedef struct UDPElem {$/;"	s	file:
UDPElem	network.c	/^} *UDPElem;$/;"	t	typeref:struct:UDPElem	file:
UDPHeader	network.h	/^typedef struct UDPHeader {    \/\/ UDP header$/;"	s
UDPHeader	network.h	/^} UDPHeader;$/;"	t	typeref:struct:UDPHeader
UDPPort	network.h	/^typedef Uint16 UDPPort;       \/\/ UDP port, in hardware order$/;"	t
UDPReceiver	network.h	/^typedef void (* UDPReceiver)(IP *buf, int len, int broadcast,$/;"	t
Uint16	network.h	/^typedef unsigned short Uint16;$/;"	t
Uint32	network.h	/^typedef unsigned int Uint32;$/;"	t
_COUNTERS_H	counters.h	10;"	d
_DISPLAY_H	display.h	10;"	d
_INTERCORE_H	intercore.h	10;"	d
_MONITORS_H	cache_monitor.h	10;"	d
_MONITORS_H	monitor.h	10;"	d
_NETWORK_H	network.h	51;"	d
_THREADS_H	threads.h	12;"	d
_TIMERINTERRUPT_H	timerInterrupt.h	10;"	d
a	display.c	/^  Octet a;$/;"	m	struct:__anon1	file:
abortInner	tcp.c	/^static void abortInner(TCP tcp) {$/;"	f	file:
ack	tcp.c	/^  Uint32 ack;$/;"	m	struct:TCPHeader	file:
addr	network.c	/^  IPAddr addr;$/;"	m	struct:ARPCacheEntry	file:
alphaComposePixels	display.c	/^Pixel alphaComposePixels(Pixel below, Pixel above) {$/;"	f
anCount	network.c	/^  short anCount;$/;"	m	struct:DNSHeader	file:
appendStr	tftp.c	/^void appendStr(UDP *sendBuf, Uint32 *pos, char * str) {$/;"	f
appendTransmitElem	tcp.c	/^static void appendTransmitElem(TCP tcp) {$/;"	f	file:
arCount	network.c	/^  short arCount;$/;"	m	struct:DNSHeader	file:
arpCache	network.c	/^static ARPCacheEntry *arpCache;$/;"	v	file:
arpCacheSize	network.c	42;"	d	file:
arpCond	network.c	/^static Condition arpCond;$/;"	v	file:
arpInit	network.c	/^static void arpInit() {$/;"	f	file:
arpMutex	network.c	/^static Mutex arpMutex;$/;"	v	file:
arpOpcodeReply	network.c	27;"	d	file:
arpOpcodeRequest	network.c	26;"	d	file:
arpReceiver	network.c	/^void arpReceiver(MAC srce, Uint16 type, Enet *buf, Uint32 len,$/;"	f
arpSend	network.c	/^static void arpSend(int op, MAC targetMAC, IPAddr targetIP) {$/;"	f	file:
arpTypeEnet	network.c	28;"	d	file:
arp_getMAC	network.c	/^int arp_getMAC(IPAddr addr, MAC *res) {$/;"	f
arp_insert	network.c	/^void arp_insert(IPAddr addr, MAC mac) {$/;"	f
arp_remove	network.c	/^void arp_remove(IPAddr addr) {$/;"	f
assert	threads.c	15;"	d	file:
b	display.c	/^  Octet b;$/;"	m	struct:__anon1	file:
backlog	tcp.c	/^  int backlog;            \/\/ limit on length of pending$/;"	m	struct:Listener	file:
bkgd	display.h	/^  Pixel bkgd;               \/\/ canvas background color$/;"	m	struct:__anon7
bkgdIndex	display.c	/^  Octet bkgdIndex; \/\/ background color for non-painted canvas$/;"	m	struct:__anon3	file:
block	tftp.c	/^  short block; \/\/ omitted for op=RRQ,WRQ; error number for op=Error$/;"	m	struct:TFTPHeader	file:
bootpcPort	network.c	806;"	d	file:
bootpsPort	network.c	805;"	d	file:
bpp	display.c	/^  Uint16 bpp;     \/\/ bits per pixel$/;"	m	struct:__anon2	file:
broadcast	enet.c	/^  int broadcast;$/;"	m	struct:EnetPending	file:
broadcastMAC	enet.c	/^MAC broadcastMAC() {$/;"	f
buf	enet.c	/^  Enet *buf;$/;"	m	struct:EnetPending	file:
buf	network.c	/^  IP *buf;$/;"	m	struct:UDPElem	file:
buf	tcp.c	/^  IP *buf;$/;"	m	struct:TransmitElem	file:
bytes	network.h	/^  Octet bytes[6];$/;"	m	struct:MAC
cacheAlign	intercore.h	/^static void * cacheAlign(void *unaligned) {$/;"	f
cacheControl	intercore.h	/^static volatile unsigned int* cacheControl = (unsigned int *)0x0000000e;$/;"	v
cacheLineAddress	intercore.h	/^static unsigned int cacheLineAddress(void *addr) {$/;"	f
cacheMultiple	intercore.h	/^static unsigned int cacheMultiple(unsigned int len) {$/;"	f
cache_flushMem	intercore.h	/^static void cache_flushMem(void *addr, unsigned int len) {$/;"	f
cache_invalidateMem	intercore.h	/^static void cache_invalidateMem(void *addr, unsigned int len) {$/;"	f
checkTimeout	threads.c	/^static void checkTimeout() {$/;"	f	file:
checksum	network.h	/^  Uint16 checksum;            \/\/ IP header checksum, FWIW$/;"	m	struct:IPHeader
checksum	network.h	/^  Uint16 checksum;            \/\/ UDP checksum$/;"	m	struct:UDPHeader
checksum	network.h	/^  Uint16 checksum;$/;"	m	struct:ICMPHeader
checksum	tcp.c	/^  Uint16 checksum;$/;"	m	struct:TCPHeader	file:
clean_monitors	cache_monitor.h	/^static void clean_monitors(unsigned int cnt) {$/;"	f
clean_monitors	monitor.h	/^static void clean_monitors(unsigned int cnt) {$/;"	f
clearResponse	mcLibc.c	/^static void clearResponse() {$/;"	f	file:
clientIP	network.c	/^  Uint32 clientIP;$/;"	m	struct:DHCPHeader	file:
clockFrequency	intercore.h	/^static unsigned int clockFrequency() {$/;"	f
clockFrequency	threads.c	/^static unsigned int clockFrequency() {$/;"	f	file:
code	network.h	/^  Octet code;$/;"	m	struct:ICMPHeader
colors	display.h	/^  Pixel *colors;            \/\/ global color table, or NULL$/;"	m	struct:__anon7
colors	display.h	/^  Pixel *colors;            \/\/ local color table, or NULL$/;"	m	struct:OneGifImage
condition_broadcast	threads.c	/^void condition_broadcast(Condition c) {$/;"	f
condition_create	threads.c	/^Condition condition_create() {$/;"	f
condition_signal	threads.c	/^void condition_signal(Condition c) {$/;"	f
condition_timedWait	threads.c	/^int condition_timedWait(Condition c, Mutex m, Microsecs microsecs) {$/;"	f
condition_wait	threads.h	/^static void condition_wait(Condition c, Mutex m) {$/;"	f
configInit	network.c	/^static void configInit() {$/;"	f	file:
corenum	intercore.h	/^static unsigned int corenum () {$/;"	f
count	threads.c	/^  int count;$/;"	m	struct:Semaphore	file:
counters_readAndZero	counters.h	/^static unsigned int counters_readAndZero(int n) {$/;"	f
counters_start	counters.h	/^static void counters_start() {$/;"	f
counters_stop	counters.h	/^static void counters_stop() {$/;"	f
createFrame	display.c	/^Image *createFrame() {$/;"	f
createImage	display.c	/^Image *createImage(int w, int h) {$/;"	f
createPixel	display.h	/^static Pixel createPixel(Octet r, Octet g, Octet b, Octet transparency) {$/;"	f
createTcp	tcp.c	/^static TCP createTcp(TCPPort localPort, IPAddr remoteAddr,$/;"	f	file:
cycleCounter	intercore.h	/^static volatile unsigned int* cycleCounter = (unsigned int *)0x00000022;$/;"	v
cycles	threads.c	/^static volatile unsigned int *cycles = (unsigned int *)0x22;$/;"	v	file:
dSize	display.c	/^  Uint32 dSize;   \/\/ size of the pixel data$/;"	m	struct:__anon2	file:
data	network.h	/^  Octet data[enetPayloadSize];$/;"	m	struct:Enet
data	network.h	/^  Octet data[icmpPayloadSize]; \/\/ enough for maximum IP header plus 8 bytes$/;"	m	struct:ICMP
data	network.h	/^  Octet data[ipPayloadSize];  \/\/ IP options and payload$/;"	m	struct:IP
data	network.h	/^  Octet data[udpPayloadSize];$/;"	m	struct:UDP
dataOffset	display.c	/^  Uint32 dataOffset;$/;"	m	struct:__anon2	file:
dead	threads.c	/^static struct Queue dead;     \/\/ Threads that have terminated, for re-use$/;"	v	typeref:struct:Queue	file:
delayLS	display.h	/^  Octet delayLS;$/;"	m	struct:__anon6
delayMS	display.h	/^  Octet delayMS;$/;"	m	struct:__anon6
deleteTcp	tcp.c	/^static void deleteTcp(TCP tcp) {$/;"	f	file:
dequeue	threads.c	/^static Thread dequeue(Queue q) {$/;"	f	file:
dequeueOne	threads.c	/^static void dequeueOne(Thread t) {$/;"	f	file:
dest	network.c	/^  UDPPort dest;$/;"	m	struct:UDPElem	file:
dest	network.h	/^  Uint16 dest;$/;"	m	struct:UDPHeader
dest	network.h	/^  Uint32 dest;$/;"	m	struct:IPHeader
dest	tcp.c	/^  Uint16 dest;$/;"	m	struct:TCPHeader	file:
detached	threads.c	/^  int detached;            \/\/ true iff nobody will ever join this thread$/;"	m	struct:Thread	file:
dhcpTypeAck	network.c	812;"	d	file:
dhcpTypeDecline	network.c	811;"	d	file:
dhcpTypeDiscover	network.c	808;"	d	file:
dhcpTypeNak	network.c	813;"	d	file:
dhcpTypeOffer	network.c	809;"	d	file:
dhcpTypeRelease	network.c	814;"	d	file:
dhcpTypeRequest	network.c	810;"	d	file:
dnsClassIN	network.c	663;"	d	file:
dnsInit	network.c	/^static void dnsInit() {$/;"	f	file:
dnsMalformedQuery	network.h	606;"	d
dnsMalformedResponse	network.h	610;"	d
dnsMutex	network.c	/^static Mutex dnsMutex = NULL;$/;"	v	file:
dnsNameHasNoAddress	network.h	609;"	d
dnsNameNotFound	network.h	607;"	d
dnsNameTooLong	network.h	603;"	d
dnsNoServer	network.h	604;"	d
dnsPort	network.c	660;"	d	file:
dnsRetryLimit	network.c	665;"	d	file:
dnsServerRefused	network.h	608;"	d
dnsTimeLimit	network.c	666;"	d	file:
dnsTimeout	network.h	605;"	d
dnsTypeA	network.c	662;"	d	file:
dns_lookup	network.c	/^int dns_lookup(char *name, IPAddr *res) {$/;"	f
enetCore	enet.c	/^static unsigned int enetCore = 999;$/;"	v	file:
enetCorenum	intercore.h	/^static unsigned int enetCorenum() {$/;"	f
enetDeliver	enet.c	/^static void enetDeliver(void * arg) {$/;"	f	file:
enetDiscard	enet.c	/^static void enetDiscard(MAC srce, Uint16 type, Enet *buf, Uint32 len,$/;"	f	file:
enetFreeList	enet.c	/^static Enet *enetFreeList = NULL;$/;"	v	file:
enetMutex	enet.c	/^static Mutex enetMutex = NULL;$/;"	v	file:
enetPayloadSize	network.h	159;"	d
enetProtocols	enet.c	/^static EnetReceiver* enetProtocols; \/\/ receivers, indexed by protocol$/;"	v	file:
enetReceiveRequest	enet.c	/^static void enetReceiveRequest() {$/;"	f	file:
enetReceiver	enet.c	/^static void enetReceiver(unsigned int srce, unsigned int type,$/;"	f	file:
enetRecvBuf	enet.c	/^static Octet *enetRecvBuf;          \/\/ cache aligned$/;"	v	file:
enetRecvBufMargin	enet.c	83;"	d	file:
enetRecvBufReset	enet.c	/^static int enetRecvBufReset = 0;    \/\/ told controller about new memory$/;"	v	file:
enetRecvBufSize	enet.c	82;"	d	file:
enetRecvCond	enet.c	/^static Condition enetRecvCond = NULL;$/;"	v	file:
enetSeed	enet.c	/^static unsigned int enetSeed;       \/\/ current seed for enet_random$/;"	v	file:
enetSendBuf	enet.c	/^static Octet *enetSendBuf;$/;"	v	file:
enetSendBufSize	enet.c	75;"	d	file:
enetSendCond	enet.c	/^static Condition enetSendCond = NULL;$/;"	v	file:
enetSendPos	enet.c	/^static unsigned int enetSendPos;    \/\/ next free position in enetSendBuf$/;"	v	file:
enetTypeARP	network.h	153;"	d
enetTypeIP	network.h	152;"	d
enet_alloc	enet.c	/^Enet *enet_alloc() {$/;"	f
enet_free	enet.c	/^void enet_free(Enet *buf) {$/;"	f
enet_init	enet.c	/^void enet_init() {$/;"	f
enet_localMAC	enet.c	/^MAC enet_localMAC() {$/;"	f
enet_random	enet.c	/^unsigned int enet_random() {$/;"	f
enet_register	enet.c	/^void enet_register(Uint16 protocol, EnetReceiver receiver) {$/;"	f
enet_send	enet.c	/^void enet_send(MAC dest, Uint16 type, Enet *buf, Uint32 len) {$/;"	f
enqueue	threads.c	/^static inline void enqueue(Queue q, Thread t) {$/;"	f	file:
fSize	display.c	/^  Uint32 fSize;$/;"	m	struct:__anon2	file:
failed	tcp.c	/^  int failed;             \/\/ set iff closed by timeout, RESET, or tcp_abort$/;"	m	struct:TCP	file:
file	network.c	/^  Octet file[128];$/;"	m	struct:DHCPHeader	file:
fillRect	display.c	/^void fillRect(Image *dest, Pixel pixel, int x, int y, int w, int h) {$/;"	f
findTcp	tcp.c	/^static TCP findTcp(TCPPort localPort, IPAddr remoteAddr,$/;"	f	file:
first	display.h	/^  OneGifImage *first;       \/\/ first image, or NULL$/;"	m	struct:__anon7
firstSentAt	tcp.c	/^  Microsecs firstSentAt;  \/\/ time at which buf was first transmitted$/;"	m	struct:TransmitElem	file:
flag	tcp.c	/^  Uint16 flag;            \/\/ extra flag for transmission (PUSH or FIN)$/;"	m	struct:TransmitElem	file:
flagAck	tcp.c	37;"	d	file:
flagFin	tcp.c	33;"	d	file:
flagPush	tcp.c	36;"	d	file:
flagReset	tcp.c	35;"	d	file:
flagSyn	tcp.c	34;"	d	file:
flagUrgent	tcp.c	38;"	d	file:
flags	network.c	/^  Uint16 flags;$/;"	m	struct:DHCPHeader	file:
flushImage	display.c	/^void flushImage(Image *image) {$/;"	f
forkArg	threads.c	/^  void * forkArg;          \/\/ argument to be passed to forkee$/;"	m	struct:Thread	file:
forkCount	threads.c	/^static int forkCount = 0;     \/\/ UID generator for forked threads$/;"	v	file:
forkee	mcMain.c	/^static void forkee(void *arg) {$/;"	f	file:
forkee	threads.c	/^  void (* forkee)(void *); \/\/ target of "fork" call$/;"	m	struct:Thread	file:
fp	intercore.h	/^  unsigned int fp;$/;"	m	struct:SaveArea
frag	network.h	/^  Uint16 frag;                \/\/ fragmentation details; use 0 normally$/;"	m	struct:IPHeader
free	mcLibc.c	/^void free(void *ptr) {$/;"	f
freeImage	display.c	/^void freeImage(Image *image) {$/;"	f
fromMAC	enet.c	/^  MAC fromMAC;$/;"	m	struct:EnetPending	file:
gce	display.h	/^  GifGCE gce;               \/\/ the image's GCE if any, defaulted to 0$/;"	m	struct:OneGifImage
getResponse	mcLibc.c	/^static int getResponse() {$/;"	f	file:
getSaveArea	intercore.h	/^static SaveArea *getSaveArea(int n) {$/;"	f
h	display.h	/^  Uint32 h;$/;"	m	struct:__anon5
h	display.h	/^  int h;$/;"	m	struct:OneGifImage
h	display.h	/^  int h;$/;"	m	struct:__anon7
hLS	display.c	/^  Octet hLS;       \/\/ canvas height$/;"	m	struct:__anon3	file:
hLS	display.c	/^  Octet hLS;$/;"	m	struct:__anon4	file:
hMS	display.c	/^  Octet hMS;$/;"	m	struct:__anon3	file:
hMS	display.c	/^  Octet hMS;$/;"	m	struct:__anon4	file:
hRes	display.c	/^  Uint32 hRes;    \/\/ horizontal resolution, pixels per meter (!)$/;"	m	struct:__anon2	file:
hSize	display.c	/^  Uint32 hSize;   \/\/ header byte count, 40 in this case$/;"	m	struct:__anon2	file:
hardwareAddr	network.c	/^  Octet hardwareAddr[16];$/;"	m	struct:DHCPHeader	file:
hardwareAddrLength	network.c	/^  Octet hardwareAddrLength;$/;"	m	struct:DHCPHeader	file:
hardwareSize	network.c	/^  Octet hardwareSize;$/;"	m	struct:ARPPacket	file:
hardwareType	network.c	/^  Octet hardwareType;$/;"	m	struct:DHCPHeader	file:
hardwareType	network.c	/^  Uint16 hardwareType;$/;"	m	struct:ARPPacket	file:
head	threads.h	/^  Thread head;$/;"	m	struct:Queue
height	display.c	/^  Uint32 height;  \/\/ pixels$/;"	m	struct:__anon2	file:
hops	network.c	/^  Octet hops;$/;"	m	struct:DHCPHeader	file:
hton	network.h	/^static Uint32 hton(Uint32 n) {$/;"	f
htonCopy	network.h	/^static void htonCopy(Uint32 n, Octet * dest) {$/;"	f
htons	network.h	/^static Uint16 htons(Uint16 n) {$/;"	f
htonsCopy	network.h	/^static void htonsCopy(Uint16 n, Octet * dest) {$/;"	f
icSema_P	intercore.h	/^static void icSema_P(int n) {$/;"	f
icSema_tryP	intercore.h	/^static int icSema_tryP(int n) {$/;"	f
icSleep	intercore.h	/^static int icSleep(unsigned int n) {$/;"	f
icmp	network.h	/^  ICMPHeader icmp;$/;"	m	struct:ICMP
icmpChecksum	network.c	/^static Uint16 icmpChecksum(IP *buf, Uint32 len) {$/;"	f	file:
icmpCodePortUnreachable	network.h	326;"	d
icmpCodeProtocolUnreachable	network.h	325;"	d
icmpDiscard	network.c	/^static void icmpDiscard(IP *buf, Uint32 len) {$/;"	f	file:
icmpEcho	network.c	/^static void icmpEcho(IP *buf, Uint32 len) {$/;"	f	file:
icmpInit	network.c	/^static void icmpInit() {$/;"	f	file:
icmpMutex	network.c	/^static Mutex icmpMutex = NULL;$/;"	v	file:
icmpPayloadSize	network.h	328;"	d
icmpReceiver	network.c	/^static void icmpReceiver(IP *buf, Uint32 len, int broadcast) {$/;"	f	file:
icmpTransportProblem	network.c	/^static void icmpTransportProblem(IP *buf, Uint32 len) {$/;"	f	file:
icmpTypeDestinationUnreachable	network.h	314;"	d
icmpTypeEchoReply	network.h	313;"	d
icmpTypeEchoRequest	network.h	317;"	d
icmpTypeInformationReply	network.h	323;"	d
icmpTypeInformationRequest	network.h	322;"	d
icmpTypeParameterProblem	network.h	319;"	d
icmpTypeRedirect	network.h	316;"	d
icmpTypeSourceQuench	network.h	315;"	d
icmpTypeTimeExceeded	network.h	318;"	d
icmpTypeTimestamp	network.h	320;"	d
icmpTypeTimestampReply	network.h	321;"	d
icmpTypes	network.c	/^static ICMPReceiver *icmpTypes; \/\/ receivers, indexed by ICMP type$/;"	v	file:
icmp_bounce	network.c	/^void icmp_bounce(IP *buf, int broadcast, Octet type, Octet code) {$/;"	f
icmp_getReceiver	network.c	/^static ICMPReceiver icmp_getReceiver(Octet type) {$/;"	f	file:
icmp_register	network.c	/^void icmp_register(Octet type, ICMPReceiver receiver) {$/;"	f
icmp_send	network.c	/^void icmp_send(ICMP *buf, Uint32 len) {$/;"	f
id	network.c	/^  short id;$/;"	m	struct:DNSHeader	file:
id	network.h	/^  Uint16 id;                  \/\/ frag\/defrag identifier$/;"	m	struct:IPHeader
id	threads.c	/^  int id;                  \/\/ unique ID assigned by "fork"$/;"	m	struct:Thread	file:
imgBytes	display.h	/^  Octet *imgBytes;          \/\/ pointer into original file, for this image$/;"	m	struct:OneGifImage
import	display.c	/^  Uint32 import;  \/\/ number of important colors in the palette$/;"	m	struct:__anon2	file:
invalidateImage	display.c	/^void invalidateImage(Image *image) {$/;"	f
ip	network.h	/^  IPHeader ip;                \/\/ static part of IP header$/;"	m	struct:IP
ip	network.h	/^  IPHeader ip;$/;"	m	struct:ICMP
ip	network.h	/^  IPHeader ip;$/;"	m	struct:UDP
ipBroadcast	network.c	/^static IPAddr ipBroadcast;      \/\/ 255.255.255.255$/;"	v	file:
ipChecksum	network.c	/^static Uint16 ipChecksum(Uint32 res, Octet *buf, Uint32 len) {$/;"	f	file:
ipDiscard	network.c	/^static void ipDiscard(IP *buf, Uint32 len, int broadcast) {$/;"	f	file:
ipHash	network.c	/^static int ipHash(IPAddr addr) {$/;"	f	file:
ipHeaderChecksum	network.c	/^static Uint16 ipHeaderChecksum(IP *buf) {$/;"	f	file:
ipHeaderValid	network.c	/^static int ipHeaderValid(IP *buf) {$/;"	f	file:
ipInit	network.c	/^static void ipInit() {$/;"	f	file:
ipIsBroadcast	network.c	/^static int ipIsBroadcast(IPAddr addr) {$/;"	f	file:
ipMutex	network.c	/^static Mutex ipMutex = NULL;$/;"	v	file:
ipPayloadSize	network.h	239;"	d
ipProtocolICMP	network.h	220;"	d
ipProtocolTCP	network.h	221;"	d
ipProtocolUDP	network.h	222;"	d
ipProtocols	network.c	/^static IPReceiver *ipProtocols; \/\/ receivers, indexed by protocol$/;"	v	file:
ipReceiver	network.c	/^static void ipReceiver(MAC srce, Uint16 type, Enet *buf, Uint32 len,$/;"	f	file:
ip_fromQuad	network.h	/^static IPAddr ip_fromQuad(Octet a, Octet b, Octet c, Octet d) {$/;"	f
ip_getReceiver	network.c	/^static IPReceiver ip_getReceiver(Octet protocol) {$/;"	f	file:
ip_headerSize	network.h	/^static Uint32 ip_headerSize(IP *buf) {$/;"	f
ip_payload	network.h	/^static Octet *ip_payload(IP *buf) {$/;"	f
ip_payloadSize	network.h	/^static Uint32 ip_payloadSize(IP *buf) {$/;"	f
ip_register	network.c	/^void ip_register(Octet protocol, IPReceiver receiver) {$/;"	f
ip_send	network.c	/^void ip_send(IP *buf, Uint32 len, Octet ttl, Octet tos) {$/;"	f
ip_setSrce	network.c	/^void ip_setSrce(IP *buf) {$/;"	f
joiner	threads.c	/^  Semaphore joiner;        \/\/ block here in Join until thread terminates$/;"	m	struct:Thread	file:
k_threadBase	threads.c	/^void * k_threadBase() {$/;"	f
leftLS	display.c	/^  Octet leftLS;$/;"	m	struct:__anon4	file:
leftMS	display.c	/^  Octet leftMS;$/;"	m	struct:__anon4	file:
len	enet.c	/^  Uint32 len;$/;"	m	struct:EnetPending	file:
len	network.c	/^  int len; \/\/ UDP payload length or negative return code$/;"	m	struct:UDPElem	file:
len	network.h	/^  Uint16 len;                 \/\/ payload bytes + header bytes (8)$/;"	m	struct:UDPHeader
len	network.h	/^  Uint16 len;                 \/\/ total length, header + options + payload$/;"	m	struct:IPHeader
len	tcp.c	/^  Uint32 len;             \/\/ TCP payload bytes currently in buf$/;"	m	struct:TransmitElem	file:
lines	display.h	/^  Pixel **lines;  \/\/ array of scan lines, each an array of native pixels$/;"	m	struct:__anon5
link	intercore.h	/^  unsigned int link;$/;"	m	struct:SaveArea
localPort	tcp.c	/^  TCPPort localPort;$/;"	m	struct:TCP	file:
mac	network.c	/^  MAC mac;$/;"	m	struct:ARPCacheEntry	file:
macKnown	enet.c	/^static int macKnown = 0;$/;"	v	file:
magicCookie	network.c	/^  Uint32 magicCookie;$/;"	m	struct:DHCPHeader	file:
main	mcMain.c	/^int main (int argc, const char * argv[]) {$/;"	f
malloc	mcLibc.c	/^void *malloc(size_t size) {$/;"	f
maxRecvWindow	tcp.c	58;"	d	file:
maxServers	network.c	656;"	d	file:
mcFree	mcLibc.c	27;"	d	file:
mcMalloc	mcLibc.c	26;"	d	file:
mcPutchar	mcLibc.c	25;"	d	file:
mc_exit	mcMain.c	/^static void mc_exit() {$/;"	f	file:
mc_initRPC	mcLibc.c	/^void mc_initRPC() {$/;"	f
messageType	network.c	/^  Octet messageType;$/;"	m	struct:DHCPHeader	file:
message_len	intercore.h	/^static unsigned int message_len(unsigned int s) {$/;"	f
message_srce	intercore.h	/^static unsigned int message_srce(unsigned int s) {$/;"	f
message_type	intercore.h	/^static unsigned int message_type(unsigned int s) {$/;"	f
method	display.c	/^  Uint32 method;  \/\/ compression method$/;"	m	struct:__anon2	file:
misc	network.c	/^  short misc;$/;"	m	struct:DNSHeader	file:
misc	network.h	/^  Uint32 misc;$/;"	m	struct:ICMPHeader
misc	tcp.c	/^  Uint16 misc;$/;"	m	struct:TCPHeader	file:
miscIO	intercore.h	/^static volatile unsigned int* miscIO = (unsigned int *)0x0000000a;$/;"	v
mqDiscard	mq.c	/^static void mqDiscard(unsigned int srce, unsigned int type,$/;"	f	file:
mqHandlers	mq.c	/^static MQReceiver *mqHandlers;$/;"	v	file:
mqInit	mq.c	/^static void mqInit() {$/;"	f	file:
mqMutex	mq.c	/^static Mutex mqMutex = NULL;$/;"	v	file:
mqReceiver	mq.c	/^static void mqReceiver(void * arg) {$/;"	f	file:
mqThread	enet.c	/^static Thread mqThread = NULL;$/;"	v	file:
mq_register	mq.c	/^void mq_register(unsigned int core, MQReceiver receiver) {$/;"	f
msgControl	intercore.h	/^static volatile unsigned int* msgControl = (unsigned int *)0x00000012;$/;"	v
msgTypeRPC	mcLibc.c	24;"	d	file:
mss	tcp.c	/^  Uint16 mss;             \/\/ Maximum receive segment size.$/;"	m	struct:MSSOption	file:
mssKind	tcp.c	/^  Octet mssKind;          \/\/ Option-kind = 2, MSS$/;"	m	struct:MSSOption	file:
mssLen	tcp.c	/^  Octet mssLen;           \/\/ Option-length = 4;$/;"	m	struct:MSSOption	file:
multiplier	intercore.h	/^static volatile unsigned int* multiplier = (unsigned int *)0x00000006;$/;"	v
mutex_acquire	threads.c	/^void mutex_acquire(Mutex m) {$/;"	f
mutex_create	threads.c	/^Mutex mutex_create() {$/;"	f
mutex_release	threads.c	/^void mutex_release(Mutex m) {$/;"	f
myDNS	network.c	/^static DNSAddrs myDNS;$/;"	v	file:
myIP	network.c	/^static IPAddr myIP = 0;$/;"	v	file:
myMAC	enet.c	/^static MAC myMAC;$/;"	v	file:
myRouter	network.c	/^static IPAddr myRouter;$/;"	v	file:
mySubnetMask	network.c	/^static IPAddr mySubnetMask;$/;"	v	file:
networkInit	network.c	/^static void networkInit() {$/;"	f	file:
next	display.h	/^  struct OneGifImage *next; \/\/ next image, or NULL$/;"	m	struct:OneGifImage	typeref:struct:OneGifImage::OneGifImage
next	enet.c	/^  struct EnetPending *next;$/;"	m	struct:EnetPending	typeref:struct:EnetPending::EnetPending	file:
next	network.c	/^  struct UDPElem *next;$/;"	m	struct:UDPElem	typeref:struct:UDPElem::UDPElem	file:
next	network.h	/^  struct Enet *next;$/;"	m	struct:Enet	typeref:struct:Enet::Enet
next	network.h	/^  struct IP *next;            \/\/ not used by IP; available for clients.$/;"	m	struct:IP	typeref:struct:IP::IP
next	tcp.c	/^  struct TransmitElem *next;$/;"	m	struct:TransmitElem	typeref:struct:TransmitElem::TransmitElem	file:
next	threads.c	/^  Thread next;             \/\/ thread queue link$/;"	m	struct:Thread	file:
nextActive	tcp.c	/^  TCP nextActive;         \/\/ list of connections for localPort$/;"	m	struct:TCP	file:
nextPending	tcp.c	/^  TCP nextPending;        \/\/ list of not-yet-accepted connections$/;"	m	struct:TCP	file:
nextServerIP	network.c	/^  Uint32 nextServerIP;$/;"	m	struct:DHCPHeader	file:
now	threads.c	/^static Cycles now = 1;        \/\/ inferred high precision cycle counter$/;"	v	file:
nsCount	network.c	/^  short nsCount;$/;"	m	struct:DNSHeader	file:
ntoh	network.h	/^static Uint32 ntoh(Uint32 n) {$/;"	f
ntohCopy	network.h	/^static Uint32 ntohCopy(Octet * srce) {$/;"	f
ntohs	network.h	/^static Uint16 ntohs(Uint16 n) {$/;"	f
ntohsCopy	network.h	/^static Uint16 ntohsCopy(Octet * srce) {$/;"	f
op	tftp.c	/^  short op;$/;"	m	struct:TFTPHeader	file:
opcode	network.c	/^  Uint16 opcode;$/;"	m	struct:ARPPacket	file:
outOfOrderHead	tcp.c	/^  IP *outOfOrderHead;     \/\/ head of ouot-of-order packet queue$/;"	m	struct:TCP	file:
outOfOrderTail	tcp.c	/^  IP *outOfOrderTail;     \/\/ tail of out-of-order packet queue$/;"	m	struct:TCP	file:
packed	display.c	/^  Octet packed;    \/\/ odds and ends$/;"	m	struct:__anon3	file:
packed	display.c	/^  Octet packed;$/;"	m	struct:__anon4	file:
packed	display.h	/^  Octet packed;$/;"	m	struct:__anon6
paintImage	display.c	/^void paintImage(Image *dest, Image *copy, Image *srce, int x, int y) {$/;"	f
paintPixel	display.h	/^static inline void paintPixel(Pixel *dest, Pixel srce) {$/;"	f
paintRepeat	display.c	/^void paintRepeat(Image *dest, Image *srce, int x, int y, int w, int h) {$/;"	f
palette	display.c	/^  Uint32 palette; \/\/ palette size, 2^n if 0$/;"	m	struct:__anon2	file:
payloadChecksum	network.c	/^Uint16 payloadChecksum(IP *buf, Uint32 len) {$/;"	f
pc	intercore.h	/^  unsigned int pc;$/;"	m	struct:SaveArea
pending	tcp.c	/^  TCP pending;            \/\/ queue of established but not accepted$/;"	m	struct:Listener	file:
pendingCount	tcp.c	/^  int pendingCount;       \/\/ length of pending$/;"	m	struct:Listener	file:
pendingHead	enet.c	/^static EnetPending pendingHead = NULL;$/;"	v	file:
pendingTail	enet.c	/^static EnetPending pendingTail = NULL;$/;"	v	file:
pendingTail	tcp.c	/^  TCP pendingTail;$/;"	m	struct:Listener	file:
pixelAspectRatio	display.c	/^  Octet pixelAspectRatio;$/;"	m	struct:__anon3	file:
pixelMem	display.h	/^  void *pixelMem; \/\/ memory block allocated for "lines"$/;"	m	struct:__anon5
pl	intercore.h	/^  unsigned int pl;$/;"	m	struct:SaveArea
planes	display.c	/^  Uint16 planes;  \/\/ color plane count, always 1$/;"	m	struct:__anon2	file:
prev	network.c	/^  struct UDPElem *prev;$/;"	m	struct:UDPElem	typeref:struct:UDPElem::UDPElem	file:
prevCycles	threads.c	/^static unsigned int prevCycles; \/\/ last cycle counter seen by timer stuff$/;"	v	file:
protocol	network.h	/^  Octet protocol;             \/\/ protocol family$/;"	m	struct:IPHeader
protocolSize	network.c	/^  Octet protocolSize;$/;"	m	struct:ARPPacket	file:
protocolType	network.c	/^  Uint16 protocolType;$/;"	m	struct:ARPPacket	file:
pruneTransmitQueue	tcp.c	/^static void pruneTransmitQueue(TCP tcp) {$/;"	f	file:
putchar	mcLibc.c	/^int putchar(int c) {$/;"	f
q	threads.c	/^  Queue q;                 \/\/ thread queue this is on, or NULL$/;"	m	struct:Thread	file:
q	threads.c	/^  struct Queue q;$/;"	m	struct:Condition	typeref:struct:Condition::Queue	file:
q	threads.c	/^  struct Queue q;$/;"	m	struct:Mutex	typeref:struct:Mutex::Queue	file:
q	threads.c	/^  struct Queue q;$/;"	m	struct:Semaphore	typeref:struct:Semaphore::Queue	file:
qdCount	network.c	/^  short qdCount;$/;"	m	struct:DNSHeader	file:
queue_block	threads.c	/^int queue_block(Queue q, Microsecs microsecs) {$/;"	f
queue_init	threads.c	/^void queue_init(Queue q) {$/;"	f
queue_isEmpty	threads.c	/^int queue_isEmpty(Queue q) {$/;"	f
queue_unblock	threads.c	/^void queue_unblock(Queue q) {$/;"	f
r1	intercore.h	/^  unsigned int r1;$/;"	m	struct:SaveArea
r10	intercore.h	/^  unsigned int r10;$/;"	m	struct:SaveArea
r11	intercore.h	/^  unsigned int r11;$/;"	m	struct:SaveArea
r12	intercore.h	/^  unsigned int r12;$/;"	m	struct:SaveArea
r13	intercore.h	/^  unsigned int r13;$/;"	m	struct:SaveArea
r14	intercore.h	/^  unsigned int r14;$/;"	m	struct:SaveArea
r15	intercore.h	/^  unsigned int r15;$/;"	m	struct:SaveArea
r16	intercore.h	/^  unsigned int r16;$/;"	m	struct:SaveArea
r17	intercore.h	/^  unsigned int r17;$/;"	m	struct:SaveArea
r18	intercore.h	/^  unsigned int r18;$/;"	m	struct:SaveArea
r19	intercore.h	/^  unsigned int r19;$/;"	m	struct:SaveArea
r2	intercore.h	/^  unsigned int r2;$/;"	m	struct:SaveArea
r20	intercore.h	/^  unsigned int r20;$/;"	m	struct:SaveArea
r21	intercore.h	/^  unsigned int r21;$/;"	m	struct:SaveArea
r22	intercore.h	/^  unsigned int r22;$/;"	m	struct:SaveArea
r3	intercore.h	/^  unsigned int r3;$/;"	m	struct:SaveArea
r4	intercore.h	/^  unsigned int r4;$/;"	m	struct:SaveArea
r5	intercore.h	/^  unsigned int r5;$/;"	m	struct:SaveArea
r6	intercore.h	/^  unsigned int r6;$/;"	m	struct:SaveArea
r7	intercore.h	/^  unsigned int r7;$/;"	m	struct:SaveArea
r8	intercore.h	/^  unsigned int r8;$/;"	m	struct:SaveArea
r9	intercore.h	/^  unsigned int r9;$/;"	m	struct:SaveArea
readBmp	display.c	/^Image *readBmp(char *imgBytes, int imgLen) {$/;"	f
readClock	threads.c	/^static void readClock() {$/;"	f	file:
readDhcpOptions	network.c	/^static void readDhcpOptions(Octet *optData,$/;"	f	file:
readGif	display.c	/^GifImage *readGif(Octet *imgBytes, int imgLen) {$/;"	f
read_epc	timerInterrupt.h	/^static unsigned int read_epc() {$/;"	f
read_handlerR	timerInterrupt.h	/^static unsigned int read_handlerR() {$/;"	f
read_mask	timerInterrupt.h	/^static unsigned int read_mask() {$/;"	f
read_monitors	cache_monitor.h	/^static unsigned int read_monitors(unsigned int cnt) {$/;"	f
read_monitors	monitor.h	/^unsigned int read_monitors(unsigned int cnt) {$/;"	f
read_timeIntervals	timerInterrupt.h	/^static unsigned int read_timeIntervals() {$/;"	f
ready	threads.c	/^static struct Queue ready;    \/\/ Threads ready to run$/;"	v	typeref:struct:Queue	file:
recvBuf	tcp.c	/^  Octet *recvBuf;         \/\/ cyclic queue of data not yet consumed by client$/;"	m	struct:TCP	file:
recvBufCount	tcp.c	/^  int recvBufCount;       \/\/ amount of data in recvBuf$/;"	m	struct:TCP	file:
recvBufStart	tcp.c	/^  int recvBufStart;       \/\/ start of data in recvBuf$/;"	m	struct:TCP	file:
recvInit	tcp.c	/^  Uint32 recvInit;        \/\/ initial recv sequence number$/;"	m	struct:TCP	file:
recvNext	tcp.c	/^  Uint32 recvNext;        \/\/ sequence number of next byte to be received$/;"	m	struct:TCP	file:
recvPushed	tcp.c	/^  int recvPushed;         \/\/ last received byte had the PUSH flag set$/;"	m	struct:TCP	file:
recvWindow	tcp.c	/^  Uint32 recvWindow;      \/\/ byte count relative to recvNext$/;"	m	struct:TCP	file:
relayAgentIP	network.c	/^  Uint32 relayAgentIP;$/;"	m	struct:DHCPHeader	file:
releaseRS232	intercore.h	/^static void releaseRS232() {$/;"	f
remoteAddr	tcp.c	/^  IPAddr remoteAddr;$/;"	m	struct:Listener	file:
remoteAddr	tcp.c	/^  IPAddr remoteAddr;$/;"	m	struct:TCP	file:
remotePort	tcp.c	/^  TCPPort remotePort;$/;"	m	struct:Listener	file:
remotePort	tcp.c	/^  TCPPort remotePort;$/;"	m	struct:TCP	file:
renderGif	display.c	/^Image *renderGif(OneGifImage *gif, Pixel *gColors) {$/;"	f
reserved1	display.c	/^  Uint16 reserved1;$/;"	m	struct:__anon2	file:
reserved2	display.c	/^  Uint16 reserved2;$/;"	m	struct:__anon2	file:
retransmitter	tcp.c	/^static void retransmitter(void *arg) {$/;"	f	file:
retryLimit	tftp.c	33;"	d	file:
rpcServer	mcLibc.c	/^static void rpcServer(unsigned int core, unsigned int type,$/;"	f	file:
rqCount	intercore.h	/^  unsigned int rqCount;$/;"	m	struct:SaveArea
rqValues	intercore.h	/^  unsigned int rqValues[96];$/;"	m	struct:SaveArea
rs232	intercore.h	/^static volatile unsigned int* rs232 = (unsigned int *)0x00000002;$/;"	v
rs232	threads.c	/^static volatile unsigned int *rs232 = (unsigned int *)0x02;$/;"	v	file:
running	threads.c	/^static Thread running = NULL; \/\/ Currently executing thread$/;"	v	file:
schedule	threads.c	/^static void schedule() {$/;"	f	file:
seconds	network.c	/^  Uint16 seconds;$/;"	m	struct:DHCPHeader	file:
sem_P	threads.c	/^void sem_P(Semaphore s) {$/;"	f
sem_V	threads.c	/^void sem_V(Semaphore s) {$/;"	f
sem_create	threads.c	/^Semaphore sem_create() {$/;"	f
semaControl	intercore.h	/^static volatile unsigned int* semaControl = (unsigned int *)0x00000016;$/;"	v
sendData	tcp.c	/^static void sendData(TCP tcp) {$/;"	f	file:
sendInProgress	enet.c	/^static int sendInProgress;          \/\/ waiting for a transmit ack$/;"	v	file:
sendInit	tcp.c	/^  Uint32 sendInit;        \/\/ sequence number of our initial SYN$/;"	m	struct:TCP	file:
sendNagled	tcp.c	/^  Uint32 sendNagled;      \/\/ bool: transmission was blocked by Nagle$/;"	m	struct:TCP	file:
sendNext	tcp.c	/^  Uint32 sendNext;        \/\/ sequence number of next byte for transmit queue$/;"	m	struct:TCP	file:
sendSmall	tcp.c	/^static void sendSmall(TCP tcp, Uint32 seq, Uint16 flags) {$/;"	f	file:
sendUnack	tcp.c	/^  Uint32 sendUnack;       \/\/ sequence number of first unacknowledged byte$/;"	m	struct:TCP	file:
sendWindow	tcp.c	/^  Uint32 sendWindow;      \/\/ relative to sendUnack$/;"	m	struct:TCP	file:
senderIP	network.c	/^  Octet senderIP[4];$/;"	m	struct:ARPPacket	file:
senderMAC	network.c	/^  Octet senderMAC[6];$/;"	m	struct:ARPPacket	file:
sending	enet.c	/^IntercoreMessage sending;           \/\/ request message waiting transmit ack$/;"	v
sentAt	tcp.c	/^  Microsecs sentAt;       \/\/ time at which buf was last transmitted$/;"	m	struct:TransmitElem	file:
separator	display.c	/^  char separator;$/;"	m	struct:__anon4	file:
seq	tcp.c	/^  Uint32 seq;             \/\/ sequence number of first byte in buf$/;"	m	struct:TransmitElem	file:
seq	tcp.c	/^  Uint32 seq;$/;"	m	struct:TCPHeader	file:
seqComp	tcp.c	/^static int seqComp(Uint32 a, Uint32 b) {$/;"	f	file:
service	network.h	/^  Octet service;              \/\/ QOS, etc; use 0 normally$/;"	m	struct:IPHeader
setFrameBuffer	intercore.h	/^static int setFrameBuffer(void *frame) {$/;"	f
setResponse	mcLibc.c	/^static void setResponse(int core, int n) {$/;"	f	file:
showFrame	display.c	/^void showFrame(Image *frame) {$/;"	f
sig1	display.c	/^  char sig1;       \/\/ 'G'$/;"	m	struct:__anon3	file:
sig2	display.c	/^  char sig2;       \/\/ 'I'$/;"	m	struct:__anon3	file:
sig3	display.c	/^  char sig3;       \/\/ 'F'$/;"	m	struct:__anon3	file:
skipName	network.c	/^void skipName(Octet * recvData, int * pos, int recvLen) {$/;"	f
sname	network.c	/^  Octet sname[64];$/;"	m	struct:DHCPHeader	file:
sp	intercore.h	/^  void *sp;$/;"	m	struct:SaveArea
sp	threads.c	/^  void * sp;               \/\/ saved SP when not running$/;"	m	struct:Thread	file:
srce	network.h	/^  Uint16 srce;$/;"	m	struct:UDPHeader
srce	network.h	/^  Uint32 srce;$/;"	m	struct:IPHeader
srce	tcp.c	/^  Uint16 srce;$/;"	m	struct:TCPHeader	file:
stackBase	threads.c	/^  void * stackBase;        \/\/ allocated stack (NULL for initial thread)$/;"	m	struct:Thread	file:
stackTop	threads.c	/^  void * stackTop;         \/\/ top of stack; the thread's initial SP$/;"	m	struct:Thread	file:
state	tcp.c	/^  int state;              \/\/ the overall state machine$/;"	m	struct:TCP	file:
stateCloseWait	tcp.c	23;"	d	file:
stateClosed	tcp.c	31;"	d	file:
stateClosing	tcp.c	24;"	d	file:
stateEstablished	tcp.c	20;"	d	file:
stateFinWait1	tcp.c	21;"	d	file:
stateFinWait2	tcp.c	22;"	d	file:
stateLastAck	tcp.c	25;"	d	file:
stateSynReceived	tcp.c	19;"	d	file:
stateSynSent	tcp.c	18;"	d	file:
stateTimeWait	tcp.c	26;"	d	file:
stateTimeWaitClosed	tcp.c	27;"	d	file:
status	threads.c	/^  int status;              \/\/ result status from thread_exit, default 0$/;"	m	struct:Thread	file:
strokeRect	display.c	/^void strokeRect(Image *dest, Pixel pixel, int x, int y, int w, int h,$/;"	f
t1	intercore.h	/^  unsigned int t1;$/;"	m	struct:SaveArea
t2	intercore.h	/^  unsigned int t2;$/;"	m	struct:SaveArea
t3	intercore.h	/^  unsigned int t3;$/;"	m	struct:SaveArea
tail	threads.h	/^  Thread tail;$/;"	m	struct:Queue
targetIP	network.c	/^  Octet targetIP[4];$/;"	m	struct:ARPPacket	file:
targetMAC	network.c	/^  Octet targetMAC[6];$/;"	m	struct:ARPPacket	file:
tcpAcceptCond	tcp.c	/^static Condition tcpAcceptCond = NULL;$/;"	v	file:
tcpActive	tcp.c	/^static TCP tcpActive;            \/\/ active connection list$/;"	v	file:
tcpCloseCond	tcp.c	/^static Condition tcpCloseCond = NULL;$/;"	v	file:
tcpConnectCond	tcp.c	/^static Condition tcpConnectCond = NULL;$/;"	v	file:
tcpConnectionDied	network.h	463;"	d
tcpCreateCond	tcp.c	/^static Condition tcpCreateCond = NULL;$/;"	v	file:
tcpHeaderSize	tcp.c	/^static Uint32 tcpHeaderSize(IP *buf) {$/;"	f	file:
tcpInit	tcp.c	/^static void tcpInit() {$/;"	f	file:
tcpListeners	tcp.c	/^static Listener *tcpListeners;   \/\/ listening state; NULL if not in use$/;"	v	file:
tcpMutex	tcp.c	/^static Mutex tcpMutex = NULL;$/;"	v	file:
tcpPayload	tcp.c	/^static Octet * tcpPayload(IP *buf) {$/;"	f	file:
tcpProcessData	tcp.c	/^static int tcpProcessData(TCP tcp, IP *buf) {$/;"	f	file:
tcpProcessIncoming	tcp.c	/^static int tcpProcessIncoming(TCP tcp, IP *buf) {$/;"	f	file:
tcpReceiver	tcp.c	/^static void tcpReceiver(IP *buf, Uint32 len, int broadcast) {$/;"	f	file:
tcpRecvCond	tcp.c	/^static Condition tcpRecvCond = NULL;$/;"	v	file:
tcpRejectUnknown	tcp.c	/^static void tcpRejectUnknown(IP *buf) {$/;"	f	file:
tcpSeed	tcp.c	/^static unsigned int tcpSeed;     \/\/ state for various random numbers$/;"	v	file:
tcpSend	tcp.c	/^static void tcpSend(TCP tcp, IP *buf, Uint32 len, Uint32 bufSeq,$/;"	f	file:
tcpSendCond	tcp.c	/^static Condition tcpSendCond = NULL;$/;"	v	file:
tcpSmallBuf	tcp.c	/^static IP *tcpSmallBuf = NULL;   \/\/ for transmitting SYN, ACK, RST, etc.$/;"	v	file:
tcp_abort	tcp.c	/^void tcp_abort(TCP tcp) {$/;"	f
tcp_accept	tcp.c	/^TCP tcp_accept(TCPPort localPort, IPAddr *remoteAddr, TCPPort *remotePort,$/;"	f
tcp_close	tcp.c	/^void tcp_close(TCP tcp) {$/;"	f
tcp_connect	tcp.c	/^TCP tcp_connect(TCPPort localPort, IPAddr remoteAddr, TCPPort remotePort,$/;"	f
tcp_listen	tcp.c	/^void tcp_listen(TCPPort localPort, IPAddr remoteAddr, TCPPort remotePort,$/;"	f
tcp_push	tcp.c	/^void tcp_push(TCP tcp) {$/;"	f
tcp_recv	tcp.c	/^int tcp_recv(TCP tcp, Octet *buf, Uint32 len) {$/;"	f
tcp_send	tcp.c	/^int tcp_send(TCP tcp, Octet *buf, Uint32 len) {$/;"	f
tcp_shutdown	tcp.c	/^void tcp_shutdown(TCP tcp) {$/;"	f
tftpOpAck	tftp.c	22;"	d	file:
tftpOpData	tftp.c	21;"	d	file:
tftpOpError	tftp.c	23;"	d	file:
tftpOpRRQ	tftp.c	19;"	d	file:
tftpOpWRQ	tftp.c	20;"	d	file:
tftpPort	tftp.c	16;"	d	file:
tftpPosData	tftp.c	31;"	d	file:
tftpPosName	tftp.c	30;"	d	file:
tftp_get	tftp.c	/^char * tftp_get(IPAddr server, char * file,$/;"	f
thread_detach	threads.c	/^void thread_detach(Thread t) {$/;"	f
thread_exit	threads.c	/^void thread_exit(int status) {$/;"	f
thread_fork	threads.c	/^Thread thread_fork(void forkee(void *), void * forkArg) {$/;"	f
thread_id	threads.c	/^int thread_id(Thread t) {$/;"	f
thread_init	threads.c	/^static void thread_init() {$/;"	f	file:
thread_join	threads.c	/^int thread_join(Thread t) {$/;"	f
thread_now	threads.c	/^Microsecs thread_now() {$/;"	f
thread_self	threads.c	/^Thread thread_self() {$/;"	f
thread_sleep	threads.c	/^void thread_sleep(Microsecs microsecs) {$/;"	f
thread_xfers	threads.c	/^int thread_xfers() {$/;"	f
thread_yield	threads.c	/^void thread_yield() {$/;"	f
time	network.c	/^  Microsecs time;$/;"	m	struct:ARPCacheEntry	file:
timedOut	threads.c	/^  int timedOut;            \/\/ true iff woken up by a timeout$/;"	m	struct:Thread	file:
timeout	tftp.c	34;"	d	file:
timerInerruptControl_epc	timerInterrupt.h	/^static volatile unsigned int* timerInerruptControl_epc = (unsigned int *)0x0000007a;$/;"	v
timerInerruptControl_handlerR	timerInterrupt.h	/^static volatile unsigned int* timerInerruptControl_handlerR = (unsigned int *)0x0000005a;$/;"	v
timerInerruptControl_mask	timerInterrupt.h	/^static volatile unsigned int* timerInerruptControl_mask = (unsigned int *)0x0000001a;$/;"	v
timerInerruptControl_timeInterval	timerInterrupt.h	/^static volatile unsigned int* timerInerruptControl_timeInterval = (unsigned int *)0x0000003a;$/;"	v
topLS	display.c	/^  Octet topLS;$/;"	m	struct:__anon4	file:
topMS	display.c	/^  Octet topMS;$/;"	m	struct:__anon4	file:
tq	threads.c	/^static struct Queue tq;       \/\/ Queue of threads waiting for timed wakeup$/;"	v	typeref:struct:Queue	file:
tqDequeue	threads.c	/^static void tqDequeue(Thread t) {$/;"	f	file:
tqEnqueue	threads.c	/^static void tqEnqueue(Thread t, Microsecs microsecs) {$/;"	f	file:
tqNext	threads.c	/^  Thread tqNext;           \/\/ timer queue link$/;"	m	struct:Thread	file:
tqPrev	threads.c	/^  Thread tqPrev;           \/\/ timer queue back-pointer$/;"	m	struct:Thread	file:
tqWakeup	threads.c	/^  Cycles tqWakeup;         \/\/ value of "now" when timer expires; 0 if none$/;"	m	struct:Thread	file:
transactionID	network.c	/^  Uint32 transactionID;$/;"	m	struct:DHCPHeader	file:
transmitElemNow	tcp.c	/^static void transmitElemNow(TCP tcp, TransmitElem *elem) {$/;"	f	file:
transmitHead	tcp.c	/^  TransmitElem *transmitHead; \/\/ retransmission queue$/;"	m	struct:TCP	file:
transmitTail	tcp.c	/^  TransmitElem *transmitTail; \/\/ current, untransmitted, send buffer$/;"	m	struct:TCP	file:
transmitted	tcp.c	/^  Uint32 transmitted;     \/\/ sequence number of next byte to be transmitted$/;"	m	struct:TCP	file:
transparent	display.h	/^  Octet transparent;        \/\/ index of transparent pixel$/;"	m	struct:__anon6
ttl	network.h	/^  Octet ttl;                  \/\/ remaining hops$/;"	m	struct:IPHeader
type	enet.c	/^  Uint16 type;$/;"	m	struct:EnetPending	file:
type	network.h	/^  Octet type;$/;"	m	struct:ICMPHeader
udp	network.h	/^  UDPHeader udp;$/;"	m	struct:UDP
udpCond	network.c	/^static Condition udpCond = NULL;$/;"	v	file:
udpDeliver	network.c	/^static void udpDeliver(IP *buf, int len, int broadcast, UDPPort dest) {$/;"	f	file:
udpDiscard	network.c	/^static void udpDiscard(IP *buf, int len, int broadcast, UDPPort port) {$/;"	f	file:
udpEnqueue	network.c	/^static void udpEnqueue(IP *buf, int len, int broadcast, UDPPort dest) {$/;"	f	file:
udpHead	network.c	/^static UDPElem udpHead = NULL;   \/\/ head of received UDP packet queue$/;"	v	file:
udpInit	network.c	/^static void udpInit() {$/;"	f	file:
udpMutex	network.c	/^static Mutex udpMutex = NULL;$/;"	v	file:
udpPayloadSize	network.h	396;"	d
udpPorts	network.c	/^static UDPReceiver *udpPorts;    \/\/ receivers, indexed by port number$/;"	v	file:
udpReceiver	network.c	/^static void udpReceiver(IP *buf, Uint32 len, int broadcast) {$/;"	f	file:
udpRecvHostUnreachable	network.h	384;"	d
udpRecvPortUnreachable	network.h	385;"	d
udpRecvTimeout	network.h	383;"	d
udpTail	network.c	/^static UDPElem udpTail = NULL;   \/\/ tail of received UDP packet queue$/;"	v	file:
udp_allocPort	network.c	/^UDPPort udp_allocPort(UDPReceiver receiver) {$/;"	f
udp_freePort	network.c	/^void udp_freePort(UDPPort p) {$/;"	f
udp_payload	network.h	/^static Octet *udp_payload(IP *buf) {$/;"	f
udp_recv	network.c	/^int udp_recv(IP ** buf, UDPPort p, Microsecs microsecs) {$/;"	f
udp_recvDone	network.c	/^void udp_recvDone(IP * buf) {$/;"	f
udp_register	network.c	/^void udp_register(UDPPort p, UDPReceiver receiver) {$/;"	f
udp_send	network.c	/^void udp_send(UDP *buf, Uint32 len) {$/;"	f
unlocked	threads.c	/^  int unlocked;$/;"	m	struct:Mutex	file:
urgent	tcp.c	/^  Uint16 urgent;$/;"	m	struct:TCPHeader	file:
vRes	display.c	/^  Uint32 vRes;    \/\/ vertical resolution$/;"	m	struct:__anon2	file:
vb	intercore.h	/^  unsigned int vb;$/;"	m	struct:SaveArea
ver1	display.c	/^  char ver1;$/;"	m	struct:__anon3	file:
ver2	display.c	/^  char ver2;$/;"	m	struct:__anon3	file:
ver3	display.c	/^  char ver3;$/;"	m	struct:__anon3	file:
versionAndLen	network.h	/^  Octet versionAndLen;        \/\/ 0x45 for IPv4 with no options$/;"	m	struct:IPHeader
w	display.h	/^  Uint32 w;$/;"	m	struct:__anon5
w	display.h	/^  int w;                    \/\/ canvas size$/;"	m	struct:__anon7
w	display.h	/^  int w;                    \/\/ size of this image$/;"	m	struct:OneGifImage
wLS	display.c	/^  Octet wLS;       \/\/ canvas width$/;"	m	struct:__anon3	file:
wLS	display.c	/^  Octet wLS;$/;"	m	struct:__anon4	file:
wMS	display.c	/^  Octet wMS;$/;"	m	struct:__anon3	file:
wMS	display.c	/^  Octet wMS;$/;"	m	struct:__anon4	file:
waitRS232Out	intercore.h	/^static void waitRS232Out() {$/;"	f
width	display.c	/^  Uint32 width;   \/\/ pixels$/;"	m	struct:__anon2	file:
window	tcp.c	/^  Uint16 window;$/;"	m	struct:TCPHeader	file:
x	display.h	/^  int x;                    \/\/ position of this image on the GIF's canvas$/;"	m	struct:OneGifImage
xferCount	threads.c	/^static int xferCount = 0;     \/\/ performance counter$/;"	v	file:
y	display.h	/^  int y;$/;"	m	struct:OneGifImage
yourIP	network.c	/^  Uint32 yourIP;$/;"	m	struct:DHCPHeader	file:
